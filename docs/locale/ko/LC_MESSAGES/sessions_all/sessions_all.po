# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Lablup Inc.
# This file is distributed under the same license as the Backend.AI Console
# User Guide package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
msgid ""
msgstr ""
"Project-Id-Version: Backend.AI Console User Guide 20.03\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-07 19:10+0900\n"
"PO-Revision-Date: 2024-03-05 16:00+0900\n"
"Last-Translator: \n"
"Language: ko_KR\n"
"Language-Team: \n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.14.0\n"

#: ../../sessions_all/sessions_all.rst:3
msgid "Compute Sessions"
msgstr "연산 세션"

#: ../../sessions_all/sessions_all.rst:5
msgid ""
"The most visited pages in the Backend.AI Web-UI would be the Sessions and"
" Data & Storage pages. Here, you will learn how to query and create "
"container-based compute sessions and utilize various web applications on "
"the Sessions page."
msgstr ""
"Backend.AI Web-UI 에서 가장 많이 방문하게 될 페이지는 Sessions 와 Storage 페이지입니다. "
"Sessions 페이지에서는 컨테이너 기반의 연산 세션을 조회하거나 생성 및 사용할 수 있고, Storage 페이지에서는 데이터를 "
"보관하는 저장 폴더를 생성할 수 있습니다. 여기서는 Sessions 페이지에서 컨테이너 기반의 연산 세션을 생성하고 각종 웹 "
"애플리케이션을 활용하는 방법을 알아봅니다."

#: ../../sessions_all/sessions_all.rst:13
msgid "Start a new session"
msgstr "새로운 세션 시작하기"

#: ../../sessions_all/sessions_all.rst:15
msgid ""
"After logging in with a user account, click Sessions on the left sidebar "
"to visit the Sessions page. Sessions page lets you start new sessions or "
"use and manage existing running sessions."
msgstr ""
"사용자 계정으로 로그인 후 좌측 메뉴의 Sessions 를 클릭하여 Sessions 페이지로 이동합니다. Sessions 페이지는 "
"새로운 연산 세션을 시작하거나 이미 실행 중인 연산 세션을 관리할 때 사용할 수 있습니다."

#: ../../sessions_all/sessions_all.rst:22
msgid ""
"Click the START button to start a new compute session. From version "
"24.03, Backend.AI offers an improved version of the session launcher "
"(NEO). If you want to use the previous dialog-style session launcher, "
"press the Classic button in the notification and create your session. For"
" instructions on how to use it, please refer to the following `link "
"<https://webui.docs.backend.ai/en/23.09_a/sessions_all/sessions_all.html>`_."
msgstr ""
"새로운 연산 세션을 시작하려면 START 버튼을 클릭합니다. Backend.AI 24.03 버전부터는 세션 런처(NEO)의 개선된 "
"버전을 제공합니다. 이전의 대화식 세션 런처를 사용하고 싶다면, 알림에서 Classic 버튼을 누르고 세션을 생성하세요. 사용 "
"방법에 대한 자세한 내용은 다음 `링크 "
"<https://webui.docs.backend.ai/ko/23.09_a/sessions_all/sessions_all.html>`_"
" 를 참고하세요."

#: ../../sessions_all/sessions_all.rst:30
msgid ""
"In the first page, you need to choose the type of session, interactive or"
" batch. And you can set the session name, which is optional."
msgstr ""
"첫 번째 페이지에서는 세션의 형태인 interactive 또는 batch 를 선택해야 합니다. 그리고 세션 이름을 지정할 수 "
"있습니다. (선택사항)"

#: ../../sessions_all/sessions_all.rst:35
msgid ""
"Session type: Determines the type of the session. \"Interactive\" and "
"\"Batch\" are the two session types currently available. The following "
"are the primary distinctions between the two types:"
msgstr ""
"Session type: 세션의 형태를 결정합니다. 현재 가능한 세션 형태는 “Interactive” 와 “Batch” 두 가지가 "
"있습니다. 두 형태의 주요한 차이점은 다음과 같습니다:"

#: ../../sessions_all/sessions_all.rst:39
msgid "Interactive compute session"
msgstr "Interactive 형태 연산 세션"

#: ../../sessions_all/sessions_all.rst:41
msgid "This type has been supported from the initial version of Backend.AI."
msgstr "Backend.AI 초기 버전부터 지원하던 형태입니다."

#: ../../sessions_all/sessions_all.rst:42
msgid ""
"The compute session is used in a way that the user interacts with after "
"creating a session without specifying a pre-defined execution script or "
"command."
msgstr "사용자가 별도의 실행 스크립트를 지정하지 않고 일단 세션을 생성한 후 상호 작용하는 방식으로 세션을 사용하게 됩니다."

#: ../../sessions_all/sessions_all.rst:45
msgid ""
"The session is not terminated automatically unless user explicitly "
"destroys the session or session garbage collectors are set by the admin."
msgstr ""
"사용자가 명시적으로 삭제하지 않는 한 세션은 자동 삭제되지 않습니다. 다만, 관리자가 별도의 세션 자동 수거 설정을 켜둔 경우에는,"
" 그 조건에 따라 자동으로 삭제될 수도 있습니다."

#: ../../sessions_all/sessions_all.rst:48
msgid "Batch compute session"
msgstr "Batch 형태 연산 세션"

#: ../../sessions_all/sessions_all.rst:50
msgid ""
"This type of session is supported via GUI from Backend.AI 22.03 (CLI has "
"supported the batch-type session before the 22.03)."
msgstr "Backend.AI 22.03 부터 GUI 를 통해 제공합니다. 다만, CLI 의 경우에는 그 이전부터 지원하고 있었습니다."

#: ../../sessions_all/sessions_all.rst:52
msgid ""
"Pre-define the script that will be executed when a compute session is "
"ready."
msgstr "사용자가 연산 세션을 생성할 때 실행할 스크립트를 미리 지정합니다."

#: ../../sessions_all/sessions_all.rst:54
msgid ""
"Executes the script as soon as the compute session is ready, and then "
"automatically terminates the session as soon as the execution finishes. "
"So, it will more efficiently and flexibly utilize the server farm's "
"resources if a user can write the execution script in advance or is "
"building a pipeline of workloads."
msgstr ""
"자원이 할당되는 즉시 해당 스크립트를 실행하고, 스크립트가 종료되는 그 즉시 연산 세션을 자동으로 삭제합니다. 따라서, 실행할 "
"코드가 사전에 정의되어 있거나 작업을 파이프라이닝 하는 경우에는, 연산 서버 팜(server farm)의 자원을 보다 효율적으로 "
"활용할 수 있는 장점이 있습니다."

#: ../../sessions_all/sessions_all.rst:59
msgid ""
"You can set the start time of a batch-type compute session. However, it "
"does not guarantee the session will be created at that time. It may still"
" be PENDING due to the lack of resources, etc. Rather, it guarantees that"
" the session WILL NOT run until the start time."
msgstr ""
"연산 세션 시작 시점을 지정할 수 있습니다. 다만, 시작 시점에 반드시 연산 세션이 자원을 할당받을 수 있는 것은 아닙니다(자원 "
"부족 등의 이유로 PENDING 상태에 계속 머물 수 있습니다). 시작 시점 이전에는 자원이 있어도 연산 세션을 스케줄링 하지 않는"
" 개념으로 이해하는 것이 정확합니다."

#: ../../sessions_all/sessions_all.rst:67
msgid ""
"Session name: You can specify the name of the compute session to be "
"created. If set, this name appears in Session Info, so it is easy to "
"distinguish among multiple computation sessions. If not specified, a "
"random word is assigned automatically. Session names only accept "
"alphanumeric characters between 4 and 64 without spaces."
msgstr ""
"Session name: 생성할 연산 세션의 이름을 지정할 수 있습니다. 지정하면 Session Info에 이 이름이 나타나므로 "
"연산 세션의 구분이 용이합니다. 지정하지 않으면 임의의 이름이 자동으로 지정됩니다. 세션 이름은 4-64자 사이의 알파벳 또는 "
"숫자만 받아들이며, 공백은 허용되지 않습니다."

#: ../../sessions_all/sessions_all.rst:73
msgid ""
"Click the Next button below, or the Environments & Resource allocation on"
" the right to proceed to the next page. If you want to create a session "
"without any further settings, press the Skip to review button. button. In"
" this case, the settings on the other pages will all use the default "
"values."
msgstr ""
"다음 페이지로 진행하려면 아래쪽의 Next 버튼을 클릭하거나, 우측의 Environments & Resource allocation"
" 버튼을 클릭하십시오. 추가 설정 없이 세션을 생성하려면 Skip to review 버튼을 누르십시오. 이 경우, 다른 페이지의 "
"설정은 모두 기본값을 사용하게 됩니다."

#: ../../sessions_all/sessions_all.rst:78
msgid ""
"For detailed explanations of each item that can be set on the second "
"page, please refer to the following."
msgstr "두 번째 페이지에서 설정할 수 있는 각 항목에 대한 자세한 설명은 다음을 참고하십시오."

#: ../../sessions_all/sessions_all.rst:84
msgid ""
"Environments: You can choose the base environment for compute sessions "
"such as TensorFlow, PyTorch, C++, etc. When you select TensorFlow, your "
"compute session will automatically include the TensorFlow library. If you"
" choose another environment, the corresponding packages will be installed"
" by default."
msgstr ""
"Environments: TensorFlow, PyTorch, C++ 등과 같은 연산 세션의 기본 환경을 지정합니다. "
"TensorFlow를 선택하면 연산 세션에서 TensorFlow 라이브러리를 사용할 수 있습니다. 다른 환경을 선택하면 해당 환경이"
" 기본적으로 설치된 연산 세션을 생성하게 됩니다."

#: ../../sessions_all/sessions_all.rst:88
msgid ""
"Version: Selects the version of the environment. For example, you can "
"select different versions, such as 1.15, 2.3, etc., for the TensorFlow "
"environment."
msgstr ""
"Version: 환경의 버전을 선택합니다. 예를 들어, TensorFlow 환경에서는 1.15, 2.3 등과 같은 버전을 선택할 수"
" 있습니다."

#: ../../sessions_all/sessions_all.rst:90
msgid ""
"Image Name: You can specify the name of the image to be used for the "
"compute session. Depending on your environment settings, this "
"configurations may not be available."
msgstr ""
"Image Name: 연산 세션에 사용할 이미지의 이름을 지정할 수 있습니다. 환경 설정에 따라 이 설정이 사용 불가능할 수도 "
"있습니다."

#: ../../sessions_all/sessions_all.rst:93
msgid ""
"Set Environment Variable: Provides an interface for users to set "
"environment variables in a compute session. See the section :ref:`How to "
"add environment variables before session creation<set-environment-"
"variables>` on how to use."
msgstr ""
"Set Environment Variable: 사용자가 연산 세션에 환경 변수를 설정할 수 있는 인터페이스를 제공합니다. 사용 "
"방법은 :ref:`세션 생성하기 전에 환경 변수를 추가하는 방법<set-environment-variables>` 섹션을 "
"참고하십시오."

#: ../../sessions_all/sessions_all.rst:97
msgid ""
"Resource Group: Specifies the resource group in which to create a compute"
" session. A resource group is a unit that groups host servers that each "
"user can access. Usually, servers in a resource group would have the same"
" type of GPU resources. Administrators can classify servers by any "
"criteria, group them into one or more resource groups, and configure "
"which resource groups a user can use. Users can launch a compute session "
"only on servers in resource groups allowed by the administrator. If you "
"are allowed multiple resource groups, you can select any group you want, "
"but you cannot change it if you have only one."
msgstr ""
"Resource Group: 연산 세션을 생성할 자원 그룹을 지정합니다. 자원 그룹은 각 사용자가 접근할 수 있는 호스트 서버를 "
"묶은 단위이며, 주로 같은 종류의 GPU 자원을 보유하고 있는 서버들을 하나의 자원 그룹으로 설정합니다. 관리자는 서버를 종류별로 "
"구분하여 자원 그룹으로 묶고, 사용자가 사용할 수 있는 자원 그룹의 종류를 지정할 수 있습니다. 사용자는 관리자가 허가한 자원 그룹"
" 서버에만 연산 세션을 생성할 수 있습니다. 자원 그룹이 여러 개인 경우 원하는 그룹을 선택할 수 있지만, 하나만있는 경우에는 "
"변경할 수 없습니다."

#: ../../sessions_all/sessions_all.rst:105
msgid ""
"Resource Presets: These templates have pre-defined resource sets, such as"
" CPU, memory, and GPU, to be allocated to a compute session. "
"Administrators can define frequently used resource settings in advance. "
"By adjusting the numerical input or sliding the slider, you can allocate "
"the desired amount of resources."
msgstr ""
"Resource Presets: 이 템플릿은 연산 세션에 할당할 CPU, 메모리, GPU 등의 자원 세트를 미리 정의해 둔 "
"것입니다. 관리자는 미리 자주 사용하는 자원 설정을 정의할 수 있습니다. 숫자 입력을 조정하거나 슬라이더를 움직이면 원하는 자원량을"
" 할당할 수 있습니다."

#: ../../sessions_all/sessions_all.rst:113
msgid ""
"The meaning of each item is as follows, and you can check it by clicking "
"the Help (?) button as well."
msgstr "각 항목의 의미는 다음과 같으며, 도움말 (?) 버튼을 클릭해서 확인할 수도 있습니다."

#: ../../sessions_all/sessions_all.rst:116
msgid ""
"CPU: The CPU performs basic arithmetic, logic, controlling, and "
"input/output (I/O) operations specified by the instructions. For high "
"performance computing workloads, many CPUs are helpful, but the program "
"code must be written to use multiple CPUs."
msgstr ""
"CPU: CPU는 명령어로 지정된 기본 산술, 논리, 제어 및 입출력 (I/O) 작업을 수행합니다. 고성능 컴퓨팅 워크로드의 경우 "
"많은 CPU가 도움이 되지만, 여러 CPU를 사용하도록 프로그램 코드를 작성해야 합니다. (그렇지 않으면 대부분의 CPU는 사용되지"
" 않을 것입니다.)"

#: ../../sessions_all/sessions_all.rst:120
msgid ""
"Memory: Computer memory is a temporary storage area. It holds the data "
"and instructions that the Central Processing Unit (CPU) needs. When using"
" a GPU in a machine learning workload, you must allocate at least twice "
"the memory of the GPU to memory. Otherwise, the GPU's idle time will "
"increase, resulting in a performance penalty."
msgstr ""
"컴퓨터 메모리는 임시 저장 영역입니다. 중앙 처리 장치 (CPU)에 필요한 데이터와 명령들을 보관하는 역할을 합니다.머신 러닝 "
"워크로드를 처리할 때 GPU를 연산 장치로 사용하는 경우, GPU 메모리의 두 배 이상의 메모리를 할당해야 합니다. 그렇지 않으면 "
"GPU의 유휴 시간이 증가하여 성능이 저하됩니다."

#: ../../sessions_all/sessions_all.rst:125
msgid ""
"Shared Memory: The amount of shared memory in GB to allocate for the "
"compute session. Shared memory will use some part of the memory set in "
"RAM. Therefore, it cannot be greater than the amount specified in RAM."
msgstr ""
"Shared Memory: 연산 세션에 할당할 공유 메모리의 용량 (GB). RAM에 설정된 메모리 중 일부를 떼어 공유 메모리로 "
"사용합니다. 따라서, RAM에 지정된 양보다 클 수 없습니다."

#: ../../sessions_all/sessions_all.rst:128
msgid ""
"AI Accelerator: AI accelerators (GPUs or NPUs) are well-suited for the "
"matrix/vector computations involved in machine learning. AI accelerators "
"speed up training / inference algorithms by orders of magnitude, reducing"
" running times from weeks to days."
msgstr ""
"AI Accelerator: AI 가속기 (GPU 및 NPU)는 기계 학습과 관련된 행렬 / 벡터 계산에 적합합니다. AI 가속기는"
" 훈련 및 인퍼런스 알고리즘을 몇 배나 가속화하여 기계 학습 워크로드의 실행 시간을 몇 주에서 며칠로 줄입니다."

#: ../../sessions_all/sessions_all.rst:132
msgid ""
"Sessions: A session is a unit of computational environment that is "
"created according to a specified environment and resources. If this value"
" is set to a value greater than 1, multiple sessions corresponding to the"
" resource set above are created. If there are not enough resources "
"available, requests to create sessions that cannot be created are put on "
"the waiting queue."
msgstr ""
"세션은 지정된 환경과 자원에 따라 생성되는 계산 환경 단위입니다. 이 값을 1보다 큰 값으로 설정하면 위의 자원 설정을 이용한 여러"
" 세션이 지정한 값 만큼 동시에 생성됩니다. 세션 시작 요청 시 사용 가능한 자원이 충분하지 않은 경우, 생성하지 못한 세션 시작 "
"요청들은 생성 대기열에 추가됩니다."

#: ../../sessions_all/sessions_all.rst:137
msgid ""
"Cluster mode: Backend.AI supports cluster mode, which allows you to "
"create multiple compute sessions at once. For more information, see the "
"section :ref:`Overview of Backend.AI cluster compute session<backendai-"
"cluster-compute-session>`."
msgstr ""
"Cluster mode: Backend.AI 는 한 번에 여러 연산 세션을 생성할 수 있는 클러스터 모드를 지원합니다. 더 자세한 "
"정보는 :ref:`Backend.AI 클러스터 연산 세션 개요<backendai-cluster-compute-session>` "
"섹션을 참고하세요"

#: ../../sessions_all/sessions_all.rst:141
msgid ""
"High-Performance Computing Optimizations: Backend.AI provides configuring"
" values related to HPC Optimizations. For more information, See the "
"section :ref:`Optimizing Accelerated Computing<optimizing-accelerated-"
"computing>`."
msgstr ""
"High-Performance Computing Optimizations: Backend.AI 는 HPC 최적화 관련 값을 설정할 "
"수 있습니다. 더 자세한 정보는 :ref:`가속화 컴퓨팅 최적화하기<optimizing-accelerated-computing>` "
"섹션을 참고하세요."

#: ../../sessions_all/sessions_all.rst:145
msgid ""
"Click the Next button below, or the Data & Storage on the right to "
"proceed to the next page."
msgstr "다음 페이지로 진행하려면 아래쪽의 Next 버튼을 클릭하거나, 우측의 Data & Storage 버튼을 클릭하세요."

#: ../../sessions_all/sessions_all.rst:151
msgid ""
"Here, you can specify the data folders to mount in the compute session. "
"When a compute session is destroyed, all data is deleted altogether by "
"default, but the data stored in the mounted folders will survive. Data in"
" those folders can also be reused by mounting it when creating another "
"compute session. For the information on how to mount a folder and run a "
"compute session, see :ref:`Mounting Folders to a Compute Session<session-"
"mounts>`. Here, we will pass by without mounting any folder. Let's move "
"on to the next page."
msgstr ""
"여기서는 연산 세션에 마운트 할 데이터 폴더를 지정할 수 있습니다. 연산 세션이 삭제되면 기본적으로 모든 데이터가 함께 삭제되지만,"
" 여기서 마운트 한 폴더에 저장된 데이터는 삭제되지 않습니다. 마운트 폴더에 저장된 데이터는 다른 연산 세션을 생성할 때 다시 "
"마운트하여 재사용 할 수도 있습니다. 폴더를 마운트하고 연산 세션을 실행하는 방법에 대한 정보는 :ref:`연산 세션에 폴더 마운트"
"<session-mounts>` 장을 참고하십시오. 여기서는 폴더를 마운트 하지 않고 그냥 지나가겠습니다. 다음 페이지로 "
"이동합시다."

#: ../../sessions_all/sessions_all.rst:163
msgid ""
"On the fourth page, you can set Network configurations such as Preopen "
"Ports."
msgstr "네 번째 페이지에서는 사전 개방 포트와 같은 네트워크 구성을 설정할 수 있습니다."

#: ../../sessions_all/sessions_all.rst:165
msgid ""
"Set Preopen Ports: Provides an interface for users to set preopen ports "
"in a compute session. See the section :ref:`How to add preopen ports "
"before session creation <set_preopen_ports>` on how to use."
msgstr ""
"Set Preopen Ports: 사용자가 연산 세션에 사전 개방 포트를 설정할 수 있는 인터페이스를 제공합니다. 사용 방법은 "
":ref:`세션 생성하기 전에 사전 개방 포트를 추가하는 방법<set_preopen_ports>` 섹션을 참고하십시오."

#: ../../sessions_all/sessions_all.rst:169
msgid ""
"If you are done with the network setting, click the Next button below, or"
" the Confirm and Launch on the right to proceed to the last page."
msgstr ""
"네트워크 설정을 완료했다면, 아래쪽의 Next 버튼을 클릭하거나, 우측의 Confirm and Launch 버튼을 클릭하여 마지막 "
"페이지로 이동합니다."

#: ../../sessions_all/sessions_all.rst:175
msgid ""
"Now, we have reached the last page. You can view information of "
"session(s) to create, such as environment itself, allocated resources, "
"mount information, environment variables set on the previous pages, "
"preopen ports, etc. After confirming the settings, click the Launch "
"button. If there's anything you'd like to change, you can return to the "
"previous page by clicking the Previous button, or click the Edit button "
"located at the top right of each card to go directly to the relevant "
"page."
msgstr ""
"마지막 페이지에 도착했습니다. 이전 페이지에서 설정한 연산 세션 환경, 자원 할당량과 마운트 정보, 설정된 환경변수, 사전 개방 "
"포트 등의 정보를 볼 수 있습니다. 원하는 설정인지 마지막으로 확인한 후 Launch 버튼을 클릭합니다. 만약, 변경하고 싶은 "
"설정이 있다면 Previous 버튼을 클릭하여 이전 페이지로 돌아갈 수 있습니다. 혹은, 각 카드 우측 상단에 있는 Edit 버튼을"
" 눌러 해당 페이지로 돌아갈 수 있습니다."

#: ../../sessions_all/sessions_all.rst:182
msgid ""
"If there is an issue with the settings, an error will be displayed as "
"follows. Please click Edit to correct the settings."
msgstr "설정에 문제가 있는 경우, 다음과 같이 오류가 표시됩니다. 설정을 수정하려면 Edit를 클릭하십시오."

#: ../../sessions_all/sessions_all.rst:189
msgid ""
"A warning dialog appears, stating that there are no mounted folders. "
"Ignore the warning for now and click the Start button to proceed."
msgstr "아무 폴더를 마운트 하지 않았다는 경고 대화 상자가 나타납니다. 이번에는 경고를 무시하고 Start 버튼을 클릭하여 진행합니다."

#: ../../sessions_all/sessions_all.rst:197
msgid "Now a new compute session is created in the RUNNING tab."
msgstr "Running 탭에서 새로운 연산 세션이 생성되는 것을 확인합시다."

#: ../../sessions_all/sessions_all.rst:201
msgid ""
"In the RUNNING tab, you can check the information on the currently "
"running sessions. It includes both interactive and batch sessions. BATCH "
"tab and INTERACTIVE tab show only sessions corresponding to each type, "
"but only for sessions not in terminated status. FINISHED tab shows the "
"list of terminated sessions and OTHERS tab shows the compute sessions "
"with errors. For each session, you can check the information such as "
"session environments, the amount of allocated and used resources, session"
" starting time, etc."
msgstr ""
"RUNNING 탭에서 현재 실행중인 세션에 대한 정보를 확인할 수 있습니다. 여기서는 interactive, batch 타입의 세션"
" 모두 보여줍니다. BATCH 탭과 INTERACTIVE 탭은 각 타입에 해당하는 세션들만 보여주는데, 이 때 종료된 세션은 "
"해당하지 않습니다. FINISHED 탭에는 종료 된 세션 목록이 표시되고 OTHERS 탭에는 오류가 있는 컴퓨팅 세션이 표시됩니다."
" 세션 별로 세션 환경, 할당 및 사용 자원량, 세션 시작 시간 등의 정보를 확인할 수 있습니다."

#: ../../sessions_all/sessions_all.rst:210
msgid ""
"Superadmins can query all compute session information currently running "
"(or terminated) in the cluster, and users can view only the sessions they"
" have created."
msgstr ""
"수퍼어드민의 경우 현재 클러스터에서 실행 중인 (또는 종료된) 모든 세션 정보를 확인할 수 있고, 일반 사용자의 경우에는 자신이 "
"사용한 세션만 조회 가능합니다."

#: ../../sessions_all/sessions_all.rst:215
msgid ""
"Compute session list may not be displayed normally due to intermittent "
"network connection problems, and etc. This can be solved by refreshing "
"the browser page."
msgstr ""
"간헐적인 네트워크 접속 불량 등의 문제로 세션 리스트가 정상적으로 표시되지 않는 경우가 발생할 수 있습니다. 이 때는 브라우저 "
"페이지를 새로고침하면 해결할 수 있습니다."

#: ../../sessions_all/sessions_all.rst:224
msgid ""
"Backend.AI provides detailed status information for ``PENDING``, "
"``TERMINATED``, or ``CANCELLED`` sessions. In the case of ``PENDING`` "
"sessions, in particular, you can check why the session is not scheduled "
"and stuck in the ``PENDING`` status. You can see the details by clicking "
"the question mark icon right next to the status of each session."
msgstr ""
"Backend.AI 는 ``PENDING``, ``TERMINATED``, ``CANCELLED`` 세션에 대한 상세 상태 정보를 "
"제공합니다. 특히, ``PENDING`` 세션의 경우, 세션이 스케줄링 되지 않고 ``PENDING`` 상태에 머물러 있는 이유를 "
"알 수 있어 유용합니다. 상세 정보를 확인하려면, 각 세션 상태를 나타내는 부분 바로 옆에 있는 물음표 아이콘을 클릭하십시오."

#: ../../sessions_all/sessions_all.rst:232
msgid ""
"The resource statistics are displayed at the top of the screen. You can "
"check the amount of resources currently used and the total amount of "
"resources that can be allocated. The display bars are divided into upper "
"and lower parts. The upper part shows the resource allocation status in "
"the current scaling group and the lower part shows the allocation status "
"of total accessible resources."
msgstr ""
"자원 통계는 화면 상단에 표시됩니다. 현재 사용중인 자원의 양과 할당 가능한 총 자원의 양을 확인할 수 있습니다. 디스플레이 바는 "
"상단과 하단으로 나뉩니다. 상단은 현재 스케일링 그룹의 자원 할당 상태를 나타내고 하단은 접근 가능한 총 자원의 할당 상태를 "
"나타냅니다."

#: ../../sessions_all/sessions_all.rst:239
msgid ""
"Upper: (Resources allocated by the user in the current scaling group) / "
"(Total resources allocatable by the user in the current scaling group)"
msgstr "(현재 스케일링 그룹 내에서 사용자가 할당한 자원의 양) / (현재 스케일링 그룹 내에 서 사용자 할당 가능한 자원의 총합)"

#: ../../sessions_all/sessions_all.rst:242
msgid ""
"Lower: (Resources allocated by the user) / (Resources allocated by the "
"user + Total resources allocatable by the user in the current scaling "
"group)"
msgstr "(사용자가 할당한 총 자원 양) / (사용자가 할당한 총 자원 양 + 현재 스케일링 그룹 내에서 사용자가 할당 가능한 자원의 총합)"

#: ../../sessions_all/sessions_all.rst:246
msgid ""
"If the GPU resource is marked as FGPU, this means that the server is "
"serving the GPU resources in a virtualized form. Backend.AI supports GPU "
"virtualization technology that a single physical GPU can be divided and "
"shared by multiple users for better utilization. Therefore, if you want "
"to execute a task that does not require a large amount of GPU "
"computation, you can create a compute session by allocating only a "
"portion of a GPU. The amount of GPU resources that 1 FGPU actually "
"allocates may vary from system to system depending on the administrator's"
" setting."
msgstr ""
"만약 GPU 자원이 FGPU 로 표시되어 있다면, 이는 서버가 GPU 자원을 가상화된 형태로 제공하고 있다는 것을 의미합니다. "
"Backend.AI 는 하나의 물리 GPU 를 여러 개로 분할해서 여러 사용자가 나누어 사용할 수 있는 가상화 기술을 지원하고 "
"있습니다. 따라서, GPU 연산 소요가 크지 않은 작업을 수행하고자 할 경우에는 GPU 의 일부만 할당하여 연산 세션을 생성 할 수"
" 있습니다. FGPU 가 실제로 할당하는 GPU 자원의 양은 관리자 설정에 따라 시스템 별로 다양할 수 있습니다. "

#: ../../sessions_all/sessions_all.rst:255
msgid ""
"For example, if administrator has set to split one physical GPU into five"
" pieces, 5 FGPU means 1 physical GPU, or 1 FGPU means 0.2 physical GPU. "
"At this configuration, if you create a compute session by allocating 1 "
"FGPU, you can utilize SM (streaming multiprocessor) and GPU memory "
"corresponding to 0.2 physical GPU for the session."
msgstr ""
"예를 들어, 관리자가 하나의 GPU 를 다섯 조각으로 분할 설정한 경우, 5 FGPU 가 1 물리 GPU, 또는 1 FGPU 가 "
"0.2 물리 GPU 를 뜻합니다. 이 때 1 FGPU 를 설정하여 연산 세션을 생성하면, 그 세션에서는 0.2 물리 GPU 에 "
"해당하는 SM(streaming multiprocessor) 과 GPU 메모리를 활용할 수 있습니다."

#: ../../sessions_all/sessions_all.rst:265
msgid "Use Jupyter Notebook"
msgstr "Jupyter Notebook 사용하기"

#: ../../sessions_all/sessions_all.rst:267
msgid ""
"Let's look at how to use and manage compute sessions that are already "
"running. If you look at the Control panel of the session list, there are "
"several icons. When you click the first icon, the app launcher pops up "
"and shows the available app services as below. The app launcher dialog "
"also opens automatically just after the compute session is created."
msgstr ""
"이미 실행 중인 연산 세션을 사용하고 관리하는 법에 관해 살펴보겠습니다. 세션 리스트의 Control 열을 보면 몇 가지 아이콘이 "
"있습니다. 제일 첫 아이콘을 클릭하면 다음 그림과 같이 앱 런처가 뜨면서 해당 세션이 지원하는 몇 가지 앱 서비스가 뜨게 됩니다. "
"앱 런처 대화창은 연산 세션 생성 직후 자동으로 열리기도 합니다."

#: ../../sessions_all/sessions_all.rst:280
msgid ""
"There are two check options under the app icons. Opening the app with "
"each item checked applies the following features, respectively:"
msgstr "앱 아이콘 아래에는 두 가지 체크 옵션이 있습니다. 각 항목을 체크하고 앱을 띄우면 다음과 같은 기능이 반영됩니다:"

#: ../../sessions_all/sessions_all.rst:283
msgid ""
"Open app to public: Open the app to the public. Basically, web services "
"such as Terminal and Jupyter Notebook services are not accessible by "
"other users, even if the user knows the service URL, since they are "
"considered unauthenticated. However, checking this option makes it "
"possible for anyone who knows the service URL (and port number) to access"
" and use it. Of course, the user must have a network path to access the "
"service."
msgstr ""
"Open app to public : 앱을 외부에 공개합니다. 기본적으로 터미널 및 Jupyter Notebook 서비스와 같은 웹"
" 서비스는 별도 인증을 거치므로 서비스 URL을 알고 있더라도 다른 사용자가 액세스 할 수 없습니다. 그러나 이 옵션을 선택하면 "
"서비스 URL(및 포트 번호)을 아는 사람이 접근하고 사용할 수 있습니다. 물론 사용자가 서비스에 접근하려면 네트워크 경로가 "
"있어야합니다."

#: ../../sessions_all/sessions_all.rst:289
msgid ""
"Try preferred port: Without this option checked, a port number for the "
"web service is randomly assigned from the port pool prepared in advance "
"by Backend.AI. If you check this item and enter a specific port number, "
"the entered port number will be tried first. However, there is no "
"guarantee that the desired port will always be assigned because the port "
"may not exist at all in the port pool or another service may already be "
"using the port. In this case, the port number is randomly assigned."
msgstr ""
"Try preferred port: 이 옵션을 선택하지 않으면 Backend.AI에서 미리 준비한 포트 풀에서 웹 서비스의 포트 "
"번호가 무작위로 할당됩니다. 이 항목을 체크하고 특정 포트 번호를 입력하면 입력한 포트 번호를 먼저 시도합니다. 그러나 포트가 포트"
" 풀에 존재하지 않거나 다른 서비스가 이미 포트를 사용 중일 수 있기 때문에 원하는 포트가 항상 할당된다는 보장은 없습니다. 이 "
"경우 포트 번호는 임의로 할당됩니다."

#: ../../sessions_all/sessions_all.rst:297
msgid "Depending on the system configuration, these options may not be shown."
msgstr "시스템 설정에 따라, 이 옵션들은 보이지 않을 수도 있습니다."

#: ../../sessions_all/sessions_all.rst:299
msgid "Let's click on Jupyter Notebook."
msgstr "Jupyter Notebook 을 클릭해봅시다."

#: ../../sessions_all/sessions_all.rst:303
msgid ""
"A new window pops up and you can see that Jupyter Notebook is running. "
"This notebook was created inside a running compute session and can be "
"used easily with the click of a button without any other settings. Also, "
"there is no need for a separate package installation process because the "
"language environment and library provided by the computation session can "
"be used as it is. For detailed instructions on how to use Jupyter "
"Notebook, please refer to the official documentation."
msgstr ""
"새로운 창이 뜨면서 Jupyter Notebook 이 실행되는 것을 확인할 수 있습니다. 이 Notebook 은 실행 중인 연산 "
"세션 내부에서 생성된 것으로, 별다른 설정 없이 버튼 클릭만으로 손쉽게 사 용할 수 있습니다. 또한, 연산 세션이 기본적으로 "
"제공하는 언어 환경 및 라이브러리를 그대로 활용할 수 있어 별도의 패키지 설치 과정이 필요 없습니다. 자세한 Jupyter "
"Notebook 사용 법은 공식 문서 등을 참고하시기 바랍니다."

#: ../../sessions_all/sessions_all.rst:311
msgid ""
"In the notebook's file explorer, the ``id_container file`` contains a "
"private SSH key. If necessary, you can download it and use it for SSH / "
"SFTP access to the container."
msgstr ""
"Notebook 의 파일 탐색기에서 ``id_container`` 파일은 private SSH key 를 담고 있습니다. 필요할 "
"경우 다운로드 하여 컨테이너로의 SSH/SFTP 접속에 이용할 수 있습니다."

#: ../../sessions_all/sessions_all.rst:315
msgid ""
"Click the NEW button at the top right and select the Notebook for "
"Backend.AI, then the ipynb window appears where you can enter your own "
"code."
msgstr ""
"우측 상단의 NEW 버튼을 클릭한 후 Backend.AI 용 Notebook 을 선택하면 새로운 코드를 입력할 수 있는 ipynb "
"창이 뜹니다."

#: ../../sessions_all/sessions_all.rst:322
msgid ""
"In this window, you can enter and execute any code you want by using the "
"environment that session provides. The code is executed on one of the "
"Backend.AI nodes where the compute session is actually created and there "
"is no need to configure a separate environment on the local machine."
msgstr ""
"이 창에서 세션 환경에 맞는 코드를 입력하고 실행해볼 수 있습니다. 코드는 Backend.AI 서버를 구성하는 노드 중 연산 세션이"
" 실제로 생성된 노드에서 실행이 되며, 로컬 머신에는 별도 환경을 구성할 필요가 없습니다."

#: ../../sessions_all/sessions_all.rst:329
msgid ""
"When you close the window, you can find that the ``Untitled.ipynb`` file "
"is created in the notebook file explorer. Note that the files created "
"here are deleted when you terminate the session. The way to preserve "
"those files even after the session is terminated is described in the Data"
" & Storage Folders section."
msgstr ""
"창을 닫으면 Notebook 파일 탐색기에 방금 작업한 ``Untitled.ipynb`` 파일이 생성되어 있는 것을 확인할 수 "
"있습니다. 여기 생성된 파일은 세션을 삭제할 경우 같이 삭제되는 것에 주의하십시오. 생성된 파일을 세션이 사라지더라도 보존하는 "
"방법은 폴더 섹션에서 설명합니다."

#: ../../sessions_all/sessions_all.rst:338
msgid "Use web terminal"
msgstr "웹 터미널 활용"

#: ../../sessions_all/sessions_all.rst:340
msgid ""
"Return to the Session list page. This time, let's launch the terminal. "
"Click the terminal icon (the second button in the Control panel) to use "
"the container's ttyd app. A terminal will appear in a new window and you "
"can run shell commands to access the computational session as shown in "
"the following figure. If you are familiar with using commands, you can "
"easily run various Linux commands. You may notice that the "
"``Untitled.ipynb`` file automatically generated in Jupyter Notebook is "
"listed with the ``ls`` command. This shows that both apps are running in "
"the same container environment."
msgstr ""
"세션 목록 페이지로 돌아갑니다. 이번에는 터미널을 시작하겠습니다. 컨테이너의 ttyd 앱을 사용하려면 터미널 아이콘(제어판의 두 "
"번째 버튼)을 클릭합니다. 터미널이 새 창에 나타나고 다음 그림과 같이 셸 명령을 실행하여 연산 세션에 접근 할 수 있습니다. 명령"
" 사용에 익숙하다면 다양한 Linux 명령을 쉽게 실행할 수 있습니다. Jupyter Notebook에서 자동으로 생성 된 "
"``Untitled.ipynb`` 파일이 ``ls`` 명령과 함께 나열되는 것을 볼 수 있습니다. 이는 두 앱이 동일한 컨테이너 "
"환경에서 실행되고 있음을 보여줍니다."

#: ../../sessions_all/sessions_all.rst:351
msgid ""
"If you create a file here, you can immediately see it in the Jupyter "
"Notebook you opened earlier as well. Conversely, changes made to files in"
" Jupyter Notebook can also be checked right from the terminal. This is "
"because they are using the same files in the same compute session."
msgstr ""
"만약 여기서 파일을 만들면 앞서 띄운 Jupyter Notebook 에서 즉시 그 파일을 확인할 수 있 습니다. 반대로, "
"Jupyter Notebook 에서 편집한 파일의 변경 사항도 터미널에서 바로 확인할 수 있습니다. 같은 연산 세션을 사용하고 있기"
" 때문입니다."

#: ../../sessions_all/sessions_all.rst:356
msgid ""
"In addition to this, you can use web-based services such as TensorBoard, "
"Jupyter Lab, etc., depending on the type of environments provided by the "
"compute session."
msgstr ""
"이 외에도 연산 세션이 제공하는 서비스의 종류에 따라 TensorBoard, Jupyter Lab 등과 같은 웹 기반 서비스를 "
"이용할 수 있습니다."

#: ../../sessions_all/sessions_all.rst:361
msgid "Query compute session log"
msgstr "연산 세션 로그 조회"

#: ../../sessions_all/sessions_all.rst:363
msgid ""
"You can view the log of the compute session by clicking the last icon in "
"the Control panel of the running compute session."
msgstr "돌아가고 있는 연산 세션의 Control 열의 마지막 아이콘을 클릭하면 연산 세션의 로그를 조회할 수 있습니다."

#: ../../sessions_all/sessions_all.rst:369
msgid ""
"From 22.09, you can download session log by clicking download button on "
"upper-right side of the dialog. This feature is helpful for tracking "
"artifacts."
msgstr ""
"22.09 버전부터, 다이얼로그 우상단에 위치한 다운로드 버튼을 클릭해 세션 컨테이너 로그를 내려받을 수 있습니다. 이 기능은 "
"산출물 추적에 유용하게 사용됩니다."

#: ../../sessions_all/sessions_all.rst:373
msgid "Rename running session"
msgstr "실행중인 세션 이름 변경하기"

#: ../../sessions_all/sessions_all.rst:375
msgid ""
"You can change the name of an active session. Just click the edit icon in"
" the session information column. Write down the new name and click the "
"confirm button. The new session name should also follow the :ref:`the "
"authoring rule<session-naming-rule>`."
msgstr ""
"활성 상태에 있는 세션 이름을 변경할 수 있습니다. 세션 정보 열에 있는 편집 아이콘을 클릭한 후 새 이름을 입력하고 확인 버튼을 "
"누르기만 하면 됩니다. 다만, 새로운 세션 이름도 :ref:`세션 이름 작성 규칙<session-naming-rule>` 은 따라야"
" 합니다."

#: ../../sessions_all/sessions_all.rst:385
msgid "Delete a compute session"
msgstr "연산 세션 삭제하기"

#: ../../sessions_all/sessions_all.rst:387
msgid ""
"To terminate a specific session, simply click on the red power icon and "
"click OKAY button in the dialog. Since the data in the folder inside the "
"compute session is deleted as soon as the compute session ends, it is "
"recommended to move the data to the mounted folder or upload it to the "
"mounted folder from the beginning if you want to keep it."
msgstr ""
"특정 세션을 삭제하기 위해서는 빨간색 전원 아이콘을 누르면 됩니다. 연산 세션 내부 폴더의 데이터는 연산 세션이 종료되는 순간 같이"
" 삭제되므로, 계속 유지해야 하는 데이터라면 마운트 한 폴더에 옮기거나 처음부터 폴더에 업로드하는 것을 권합니다."

#: ../../sessions_all/sessions_all.rst:398
msgid "Idleness Checks"
msgstr "유휴 상태 검사"

#: ../../sessions_all/sessions_all.rst:400
msgid ""
"Backend.AI supports three types of inactivity (idleness) criteria for "
"automatic garbage collection of compute sessions: Max Session Lifetime, "
"Network Idle Timeout, and Utilization Checker."
msgstr ""
"Backend.AI는 최대 세션 수명 시간, 네트워크 트래픽 기반 유휴 시간, 사용량 기반 자원 수거를 기준으로 세션이 자동으로 "
"삭제될 수 있습니다."

#: ../../sessions_all/sessions_all.rst:404
msgid ""
"Idle checkers(inactivity criterion) will be displayed in the idle checks "
"column of the session list."
msgstr "연산 세션 종료 기준은 유휴 상태 검사 컬럼에서 확인할 수 있습니다."

#: ../../sessions_all/sessions_all.rst:410
msgid ""
"The meaning of idle checkers are as follows, and more detailed "
"explanations can be found by clicking the information (i) icon in the "
"idle checks column."
msgstr "각 항목의 의미는 다음과 같으며, 우측의 정보(i) 버튼을 클릭해서 자세한 설명을 확인할 수도 있습니다."

#: ../../sessions_all/sessions_all.rst:413
msgid ""
"Max Session Lifetime: Force-terminate sessions after this time from "
"creation. This measure prevents sessions from running indefinitely."
msgstr ""
"최대 세션 수명 시간: 세션 생성 후 이 시간이 지나면 세션을 강제 종료합니다. 이는 세션이 무한히 실행되는 것을 방지하기 위한 "
"조치입니다."

#: ../../sessions_all/sessions_all.rst:415
msgid ""
"Network Idle Timeout: Force-terminate sessions that do not exchange data "
"with the user (browser or web app) after this time. Traffic between the "
"user and the compute session continuously occurs when the user interacts "
"with an app, like terminal or Jupyter, by keyboard input, Jupyter cell "
"creation, etc. Jupyter cell creation, etc. If there is no interaction for"
" a certain period, the condition of garbage collection will be met. Even "
"if there is a process executing a job in the compute session, it is "
"subject to termination if there is no user interaction."
msgstr ""
"네트워크 트래픽 기반 유휴 시간: 사용자(브라우저)와 연산 세션 사이에 이 시간 동안 아무런 네트워크 트래픽이 없을 경우 연산 "
"세션을 삭제합니다. 사용자와 연산 세션 사이의 트래픽은 앱 (터미널, Jupyter 등)을 통해 상호작용(키보드 입력, "
"Jupyter 셀 생성 등) 하는 경우 지속적으로 발생합니다. 만약, 연산 세션을 띄운 채 일정 시간 동안 아무런 입력을 하지 "
"않으면 자동 삭제 조건을 만족하게 됩니다. 연산 세션에서 작업을 수행 중인 프로세스가 있더라도, 사용자와의 상호작용이 없는 경우에는"
" 삭제 대상입니다."

#: ../../sessions_all/sessions_all.rst:421
msgid ""
"Utilization Checker: Resources allocated to a compute session are "
"reclaimed based on the utilization of those resources. The decision to "
"delete is based on the following two factors:"
msgstr ""
"사용량 기반 자원 수거: 연산 세션에 할당된 자원을 자원의 활용률을 기준으로 회수합니다. 연산 세션의 삭제 여부는 다음 두 가지 "
"요소에 따라 결정됩니다:"

#: ../../sessions_all/sessions_all.rst:425
msgid ""
"Grace Period: The time during which the utilization idle checker is "
"inactive. Even with low usage, the compute session won't be terminated "
"during this period. However, once the grace period is over, if the "
"average utilization remain below the threshold during the set idle "
"timeout period, the system can terminate the session at any time. The "
"grace period is merely a guaranteed duration during which termination "
"does not occur. This measure is primarily for efficient management of "
"low-usage GPU resources."
msgstr ""
"유예 기간: 이 기간 동안은 자원 사용량 기반 체커가 작동하지 않습니다. 즉, 유예 기간이 지나기 전까지는 사용량이 기준보다 "
"낮더라도 연산 세션이 삭제되지 않습니다. 하지만 유예 기간이 지나고 나면, 설정된 유휴 시간(idle timeout) 동안의 평균 "
"자원 사용률이 기준에 미치지 못하는 경우 해당 세션이 삭제될 수 있습니다. 유예 기간은 세션 종료가 이루어지지 않는 것을 보장하는 "
"시간일 뿐입니다. 이는 주로 사용률이 낮은 GPU 자원을 효율적으로 관리하기 위한 조치입니다."

#: ../../sessions_all/sessions_all.rst:432
#, python-format
msgid ""
"Utilization Threshold: If the resource utilization of a compute session "
"does not exceed the set threshold for a certain duration (idle timeout), "
"that session will be automatically terminated. For example, if the "
"accelerator utilization threshold is set to 1%, and a compute session "
"shows a utilization of less than 1% over the idle itmeout, it becomes a "
"target for termination. Resources with empty values are excluded from the"
" garbage collection criteria."
msgstr ""
"자원 사용량 기준: 연산 세션의 자원 사용량이 일정 시간(idle timeout) 동안 설정된 기준값을 넘지 못하면, 해당 세션은 "
"자동으로 삭제됩니다. 예를 들어, 가속 장치 사용률 기준을 1%로 설정했다면 idle timeout 시간 동안 평균 가속 장치 "
"사용률이 1% 미만인 연산 세션은 삭제 대상이 됩니다. 값이 설정되지 않는 자원은 자동 삭제 기준에서 제외됩니다."

#: ../../sessions_all/sessions_all.rst:441
msgid ""
"After the grace period, sessions can be terminated anytime if utilization"
" remains low. Briefly using the resources does not extend the grace "
"period. Only the average utilization over the last idle timeout is "
"considered."
msgstr ""
"유예 기간이 지난 후에는 사용량이 낮으면 언제든지 삭제될 수 있습니다. 자원을 잠깐 사용했다고 해서 유예 기간이 연장되지 않습니다."
" 오직 현 시점으로부터 지난 idle timeout 시간 동안의 평균 자원 사용률만이 고려됩니다."

#: ../../sessions_all/sessions_all.rst:445
msgid ""
"Hovering your mouse over the Utilization Checker will display a tooltip "
"with the utilization and threshold values. The text color changes to "
"yellow and then red as the current utilization approaches the threshold "
"(indicating low resource utilization)."
msgstr ""
"사용량 기반 자원 수거에 마우스를 가져가면, 사용률과 수거 기준값을 보여주는 툴팁이 나타납니다. 현재 사용률이 수거 기준값에 "
"접근할수록(사용량이 저조할수록) 글자 색이 노란색, 빨간색 순으로 변하게 됩니다."

#: ../../sessions_all/sessions_all.rst:455
msgid ""
"Depending on the environment settings, idle checkers and resource types "
"of utilization checker's tooltip may be different."
msgstr "환경 설정 값에 따라, 유휴 상태 검사 기준과 사용량 기반 자원 수거 툴팁에 나타나는 자원 항목이 다르게 보일 수 있습니다."

#: ../../sessions_all/sessions_all.rst:462
msgid "How to add environment variable before creating a session"
msgstr "세션 생성하기 전에 환경 변수를 추가하는 방법"

#: ../../sessions_all/sessions_all.rst:464
msgid ""
"To give more convenient workspace for users, Backend.AI supports "
"environment variable setting in session launching. In this feature, you "
"can add any envs such as ``PATH`` by filling out variable name and value "
"in environment configuration dialog."
msgstr ""
"Backend.AI에서는 사용자에게 더 편리한 환경을 제공하기 위해, 세션 시작 화면에서 세션에 추가될 환경 변수 추가 기능을 "
"지원합니다. 이 기능에서 여러분은 ``PATH`` 를 비롯한 모든 환경 변수를 환경변수 설정 다이얼로그에서 환경 변수명과 환경 변수"
" 값을 입력해서 추가할 수 있습니다."

#: ../../sessions_all/sessions_all.rst:468
msgid ""
"To add environment variable, simply click + Add environment variables "
"button of the Variable. Also, you can remove the variable by clicking "
"``-`` button of the row that you want to get rid of."
msgstr ""
"더 많은 환경 변수를 추가하고 싶을 경우, 입력 필드 첫번째 행의 오른쪽에 있는  ``+ Add environment "
"variables`` 버튼을 클릭하면 됩니다. 또한 환경 변수를 지우고 싶을 경우, 역시 지우고자 하는 행의 ``-`` 버튼을 "
"클릭하면 됩니다."

#: ../../sessions_all/sessions_all.rst:-1
msgid "Env Configuration Button"
msgstr "환경 설정 버튼"

#: ../../sessions_all/sessions_all.rst:475
msgid ""
"You can input variable name and value in the same line of the input "
"fields."
msgstr "환경 변수 명과 값을 같은 행의 입력 필드에 입력할 수 있습니다."

#: ../../sessions_all/sessions_all.rst:480
msgid "How to add preopen ports before creating a session"
msgstr "세션 생성하기 전에 사전 개방 포트를 추가하는 방법"

#: ../../sessions_all/sessions_all.rst:482
msgid ""
"Backend.AI supports preopen ports setting at container startup. When "
"using this feature, there is no need to build separate images when you "
"want to expose the serving port."
msgstr ""
"Backend.AI는 컨테이너 시작 전 사전 개방 포트를 설정하는 것을 지원합니다. 이 기능을 사용하면, 서빙 포트를 노출하기 위해"
" 별도의 이미지를 추가로 빌드할 필요가 없습니다."

#: ../../sessions_all/sessions_all.rst:485
msgid ""
"To add preopen ports, simply enter multiple values separated by either a "
"comma (,) or a space."
msgstr ""

#: ../../sessions_all/sessions_all.rst:-1
msgid "Preopen Ports Configuration"
msgstr "사전 개방 포트 설정"

#: ../../sessions_all/sessions_all.rst:491
msgid ""
"In the forth page of session creation page, you can add, update and "
"delete written preopen ports. To see more detail information, please "
"click Help (?) button."
msgstr ""
"이 다이얼로그에서 여러분은 사전 개방 포트를 추가하거나, 작성한 사전 개방 포트를 갱신하거나, 삭제할 수 있습니다. 더 자세히 알고"
" 싶으실 경우 다이얼로그 헤더 부분에 있는 도움말 (?) 버튼을 클릭해주세요."

#: ../../sessions_all/sessions_all.rst:494
msgid ""
"You can input between 1024 ~ 65535 port numbers to the input fields. "
"Then, click the save button. You can check the configured preopen ports "
"in the session app launcher."
msgstr ""
"입력란에 1024 ~ 65535 사이의 포트값을 입력한 뒤, SAVE 버튼을 클릭하세요. 설정된 사전 개방 포트값은 세션 앱 "
"런처에서 확인할 수 있습니다."

#: ../../sessions_all/sessions_all.rst:502
msgid ""
"The preopen ports are **internal ports within the container**. Therefore,"
" unlike other apps, when you click on the preopen ports in the session "
"app launcher, you will see a blank page. Please bind a server to the "
"respective port before using it."
msgstr ""
"사전 개방 포트는 **컨테이너 내부 포트입니다**. 따라서, 다른 앱들과 달리 세션 앱 런처에서 사전 개방 포트를 클릭하면 빈 "
"페이지가 뜹니다. 해당 포트에 서버를 먼저 바인드 한 후 사용해주세요."

#: ../../sessions_all/sessions_all.rst:507
msgid "Save container commit"
msgstr "컨테이너 커밋 저장하기"

#: ../../sessions_all/sessions_all.rst:509
msgid ""
"Backend.AI supports \\\"container commit\\\" feature from 22.09 and "
"\\\"convert session to image\\\" feature from 24.03. Committing a "
"``RUNNING`` session will save the current state of the main container as "
"a new image. Clicking the commit button in the control pane of "
"``RUNNING`` session will display a dialog to show the information of the "
"session. After checking the information, you can click the confirmation "
"button to convert the container to a new image."
msgstr ""
"Backend.AI는 22.09 버전부터 “컨테이너 커밋 기능“을 지원하고, 24.03 버전부터 “세션을 이미지로 변환하는 기능“을"
" 지원합니다. ``RUNNING`` 상태에 있는 연산 세션을 커밋하면 현재 컨테이너의 상태를 새로운 이미지로 저장할 수 있습니다. "
"``RUNNING`` 상태에 있는 연산 세션의 ``RUNNING`` 세션의 제어 열에 있는 커밋 버튼을 클릭하면 세션의 정보를 "
"보여주는 다이얼로그가 나타납니다. 정보를 확인한 후 확인 버튼을 클릭하면 컨테이너가 새로운 이미지로 변환됩니다."

#: ../../sessions_all/sessions_all.rst:-1
msgid "Container commit confirmation"
msgstr "컨테이너 커밋 확인"

#: ../../sessions_all/sessions_all.rst:519
msgid ""
"After clicking ``COMMIT`` button in the dialog, Backend.AI internally "
"requests Docker to create a new image as ``tar.gz`` to be stored into a "
"specific host path. Please note that it's not available to access "
"directly in your local environment. Users need to contact the "
"administrator to get the image file."
msgstr ""
"다이얼로그의 커밋 버튼을 클릭하게 되면, Backend.AI 에서는 내부적으로 도커에 ``tar.gz`` 형식으로 새 이미지를 "
"저장하게 됩니다. 새 이미지는 호스트 상의 특정 디렉토리에 저장되므로, 사용자의 로컬 환경에서 직접 접근할 수는 없습니다. 이미지 "
"파일을 얻기 위해서는 관리자에게 연락을 해야 합니다."

#: ../../sessions_all/sessions_all.rst:526
msgid ""
"If you want to commit ongoing session to image, check the checkbox of "
"``Convert Session to Image`` in the dialog and fill out the session name."
" The session name must be 4 to 32 characters, containing alphanumeric "
"letters or hyphen(``-``) or underscore(``_``) only. After filling out "
"session name in the input field, click the ``PUSH SESSION TO CUSTOMIZED "
"IMAGE`` button. The customized image created in this way can be used in "
"future session creations. However, directories mounted to the container "
"for image commits are considered external resources and are not included "
"in the final image."
msgstr ""
"진행 중인 세션을 이미지로 커밋하려면, 다이얼로그에서 ``Convert Session to Image`` 체크박스를 체크하고 세션 "
"이름을 입력합니다. 세션 이름은 알파벳 또는 숫자, 또는 하이픈(``-``) 이나 언더바(``_``)로 구성할 수 있으며, 최소 "
"4글자에서 32자까지만 입력해야 합니다. 세션 이름을 입력한 뒤에는 ``PUSH SESSION TO CUSTOMIZED "
"IMAGE`` 버튼을클릭합니다. 이렇게 만들어진 사용자 정의 이미지는 추후 세션 생성 시 사용할 수 있습니다. 단, 이미지 "
"커밋을 위해 컨테이너에 마운트된 디렉토리는 외부 리소스로 간주되며 최종 이미지에 포함되지 않습니다."

#: ../../sessions_all/sessions_all.rst:-1
msgid "Push session to customized image"
msgstr "사용자 정의 이미지를 세션으로 푸시"

#: ../../sessions_all/sessions_all.rst:541
msgid ""
"Currently, Backend.AI supports container commit and converting session to"
" image feature when session is ``INTERACTIVE`` mode only. During "
"container commit process, you may not be able to terminate the session to"
" prevent unexpected error. If you want to stop the ongoing process, "
"please check the session, and force-terminate the session."
msgstr ""
"현재 Backend.AI 는 세션이 ``INTERACTIVE`` 모드일 때에만 컨테이너 커밋과 세션을 이미지로 변환하는 기능을 "
"지원합니다. 또한 컨테이너 커밋 과정 동안에는 세션을 종료할 수 없는데, 이는 컨테이너 커밋 과정 중 예기치 못한 실행 에러를 "
"방지하기 위함입니다. 진행중인 컨테이너 커밋 작업을 중지하려면, 세션을 선택한 다음 강제 종료해주시기 바랍니다. "

#: ../../sessions_all/sessions_all.rst:548
msgid ""
"The number of times you can ``Convert Session to Image`` may be limited "
"by the user resource policy. In this case, try :ref:`removing the "
"existing customized image<delete-customized-image>` and retry, or contact"
" the administrator."
msgstr ""
"사용자 자원 정책에 의해 ``Convert Session to Image`` 작업 횟수가 제한될 수 있습니다. 이 경우, "
":ref:`기존 사용자 정의 이미지를 제거<delete-customized-image>` 한 후 다시 시도하거나 관리자에게 "
"문의하세요."

#: ../../sessions_all/sessions_all.rst:554
msgid "Utilizing converted images of ongoing sessions"
msgstr "진행 중인 세션의 변환된 이미지 활용"

#: ../../sessions_all/sessions_all.rst:556
msgid ""
"Converting an ongoing session into an image allows you to select this "
"image from the environments in the session launcher when creating a new "
"session. This image is not exposed to other users and is useful for "
"continuing to use the current session state as is. The converted image is"
" tagged with ``Customized<session name>``."
msgstr ""
"진행 중인 세션을 이미지로 변환하면, 다음 세션 생성 시 세션 런처의 환경 설정에서 해당 이미지를 선택하여 사용할 수 있습니다. 이"
" 이미지는 다른 사용자에게 공개되지 않으며, 현재 세션의 상태를 그대로 유지하여 사용하는 데 유용합니다. 변환된 이미지는 "
"``Customized<session name>`` 태그가 붙습니다."

#: ../../sessions_all/sessions_all.rst:-1
msgid "Select customized image"
msgstr "사용자 정의 이미지 선택"

#: ../../sessions_all/sessions_all.rst:564
msgid ""
"To manually enter the environment name for future session creation, "
"please click the copy icon."
msgstr "향후 세션 생성을 위해 환경 이름을 수동으로 입력하려면, 복사 아이콘을 누릅니다."

#: ../../sessions_all/sessions_all.rst:-1
msgid "Copy customized image"
msgstr "사용자 정의 이미지 복사"

#: ../../sessions_all/sessions_all.rst:573
msgid "Optimizing Accelerated Computing"
msgstr "가속 컴퓨팅 최적화하기"

#: ../../sessions_all/sessions_all.rst:575
msgid ""
"Backend.AI provides configuration UI for internal control variable in "
"``nthreads-var``. Backend.AI sets this value equal to the number of "
"session's CPU cores by default, which has the effect of accelerating "
"typical high-performance computing workloads. Nevertheless, for some "
"multi-thread workloads, multiple processes using OpenMP are used at same "
"time, resulting in an abnormally large number of threads and significant "
"performance degradation. To resolve this issue, setting the number of "
"threads to 1 or 2 would work."
msgstr ""
"Backend.AI 는 ``nthread-var`` 의 내부 컨트롤 변수 설정 인터페이스를 제공합니다.Backend.AI 는 "
"기본적으로 이 값을 세션의 CPU 코어 수와 같도록 설정해두며, 이는 일반적인 고성능 컴퓨팅 워크로드를 가속하는 효과가 있습니다. "
"그러나, 일부 멀티스레드 워크로드의 경우 OpenMP를 사용하는 다중 프로세스가 동시에 실행되어 비정상적으로 많은 스레드가 "
"생성되고, 현저한 성능 저하가 발생할 수 있습니다. 이러한 문제를 해결하려면, 스레드 값을 1 또는 2로 조정하십시오."

#: ../../sessions_all/sessions_all.rst:-1
msgid "Session HPC Optimization"
msgstr ""

#: ../../sessions_all/sessions_all.rst:590
msgid "Advanced web terminal usage"
msgstr "웹 터미널 고급 사용법"

#: ../../sessions_all/sessions_all.rst:592
msgid ""
"The web-based terminal internally embeds a utility called `tmux "
"<https://github.com/tmux/tmux/wiki>`_. tmux is a terminal multiplexer "
"that supports to open multiple shell windows within a single shell, so as"
" to allow multiple programs to run in foreground simultaneously. If you "
"want to take advantage of more powerful tmux features, you can refer to "
"the official tmux documentation and other usage examples on the Internet."
msgstr ""
"위에서 사용 해보았던 웹 기반 터미널은 내부적으로 `tmux <https://github.com/tmux/tmux/wiki>`_ "
"라는 유틸리티를 사용하고 있습니다. tmux 는 하나의 쉘 내에서 여러 개의 창을 띄워 다중 작업 할 수 있도록 지원하는 "
"terminal multiplexer 로, 쉘이 닫히더라도 작업하던 내용을 보존할 수 있는 등 다양한 장점을 가지고 있습니다. 보다"
" 강력한 터미널 기능을 활용하고 싶다면 tmux 공식 문서 및 기타 인터넷 상의 다양한 사용 예제를 참고하십시오."

#: ../../sessions_all/sessions_all.rst:599
msgid "Here we are introducing some simple but useful features."
msgstr "여기서는 몇 가지 간단하지만 유용한 기능을 소개하겠습니다."

#: ../../sessions_all/sessions_all.rst:602
msgid "Copy terminal contents"
msgstr "터미널 내용 복사하기"

#: ../../sessions_all/sessions_all.rst:604
msgid ""
"tmux offers a number of useful features, but it's a bit confusing for "
"first-time users. In particular, tmux has its own clipboard buffer, so "
"when copying the contents of the terminal, you can suffer from the fact "
"that it can be pasted only within tmux by default. Furthermore, it is "
"difficult to expose user system's clipboard to tmux inside web browser, "
"so the terminal contents cannot be copied and pasted to other programs of"
" user's computer. The so-called ``Ctrl-C`` / ``Ctrl-V`` is not working "
"with tmux."
msgstr ""
"tmux 는 다양한 장점을 가지고 있지만 처음 접하는 사용자라면 다소 혼란스러운 부분도 있습니 다. 특히, tmux 는 자체 "
"클립보드 버퍼를 가지고 있어 터미널의 내용을 복사할 경우 기본적으로 tmux 내에서만 붙여넣을 수 있다는 부분에서 어려움을 겪을 수"
" 있습니다. 여기에 웹 기반 터미 널에서는 사용자 시스템의 클립보드를 tmux 에 노출시키기 어렵다는 한계가 더해져서, tmux "
"쉘을 사용하고 있는 상태에서는 마우스 드래그를 통해 터미널 내용을 복사한 후 사용자 컴퓨터의 다른 프로그램에 붙여넣을 수가 "
"없습니다. 소위 말하는 ``Ctrl-C`` / ``Ctrl-V`` 가 작동하지 않는 것입니다."

#: ../../sessions_all/sessions_all.rst:612
msgid ""
"If you need to copy and paste the terminal contents to your system's "
"clipboard, you can temporarily turn off tmux's mouse support. First, "
"press ``Ctrl-B`` key to enter tmux control mode. Then type ``:set -g "
"mouse off`` and press ``Enter`` (note that you have to type the first "
"colon as well). You can check what you are typing in the status bar at "
"the bottom of the screen. Then drag the desired text from the terminal "
"with the mouse and press the ``Ctrl-C`` or ``Cmd-C`` (in Mac) to copy "
"them to the clipboard of the user's computer."
msgstr ""
"만약 터미널 내용을 사용자 시스템의 클립보드로 복사하여 붙여넣기를 할 필요가 있을 때는 잠시 tmux 의 마우스 지원 설정을 끌 수"
" 있습니다. 먼저 ``Ctrl-B`` 키를 눌러 tmux 의 제어 모드로 진입합니다. 그 후 ``:set -g mouse off``"
" 를 입력하고 엔터키를 누릅니다 (처음 콜론까지 입력해야 합니다). 입력하는 내용은 tmux 하단의 상태바에서 확인할 수 있습니다."
" 그 후 터미널에서 마우스로 원하는 텍스트를 드래그 하고 ``Ctrl-C`` 또는 ``Cmd-C`` 키를 누르면 사용자 컴퓨터의 "
"클립보드에 해당 내용이 복사 됩니다."

#: ../../sessions_all/sessions_all.rst:620
msgid ""
"With mouse support turned off, you cannot scroll through the mouse wheel "
"to see the contents of the previous page from the terminal. In this case,"
" you can turn on mouse support again. Press ``Ctrl-B``, and this time, "
"type ``:set -g mouse on``. Now you can scroll mouse wheel to see the "
"contents of the previous page."
msgstr ""
"마우스 지원을 끈 상태에서는 마우스 휠로 스크롤하여 터미널의 이전 페이지 내용을 확인할 수 없습니다. 이 때는 다시 마우스 지원을 "
"켜면 됩니다. ``Ctrl-B`` 를 누른 후 이번에는 ``:set -g mouse on`` 을 입력해봅시다. 이제 마우스 휠을 "
"스크롤하여 이전 페이지의 내용을 볼 수 있게 되었습니다."

#: ../../sessions_all/sessions_all.rst:625
msgid ""
"If you remember ``:set -g mouse off`` or ``:set -g mouse on`` after "
"``Ctrl-B``, you can use the web terminal more conveniently."
msgstr ""
"이와 같이 ``Ctrl-B`` 후 ``:set -g mouse off`` 또는 ``:set -g mouse on`` 을 기억하면 "
"조금 더 편리하게 웹 터미널을 활용할 수 있습니다."

#: ../../sessions_all/sessions_all.rst:629
msgid ""
"``Ctrl-B`` is tmux's default control mode key. If you set another control"
" key by modifying ``.tmux.conf`` in user home directory, you should press"
" the set key combination instead of ``Ctrl-B``."
msgstr ""
"``Ctrl-B`` 키는 tmux 의 기본 제어 모드 키입니다. 만약 홈 디렉토리의 ``.tmux.conf`` 를 수정하여 다른 "
"제어 키를 설정한 경우에는, ``Ctrl-B`` 대신 설정된 키 조합을 눌러야 합니다."

#: ../../sessions_all/sessions_all.rst:634
msgid "In the Windows environment, refer to the following shortcuts."
msgstr "윈도우즈 환경에서는 다음 단축키를 참고하세요."

#: ../../sessions_all/sessions_all.rst:636
msgid "Copy: Hold down ``Shift``, right-click and drag"
msgstr "복사: ``Shift`` 키를 누른 상태에서 마우스 우클릭해서 드래그"

#: ../../sessions_all/sessions_all.rst:637
msgid "Paste: Press ``Ctrl-Shift-V``"
msgstr "불여넣기: ``Ctrl-Shift-V`` 키를 누름"

#: ../../sessions_all/sessions_all.rst:640
msgid "Check the terminal history using keyboard"
msgstr "키보드를 이용해 터미널 이전 내용 확인하기"

#: ../../sessions_all/sessions_all.rst:642
msgid ""
"There is also a way to copy the terminal contents and check the previous "
"contents of the terminal simultaneously. It is to check the previous "
"contents using the keyboard. Again, click ``Ctrl-B`` first, and then "
"press the ``Page Up`` and/or ``Page Down`` keys. You can see that you "
"navigate through the terminal's history with just keyboard. To exit "
"search mode, just press the ``q`` key. With this method, you can check "
"the contents of the terminal history even when the mouse support is "
"turned off to allow copy and paste."
msgstr ""
"터미널 내용 복사도 하면서 터미널의 이전 내용도 확인하고 싶은 경우에도 방법이 있습니다. 바로 키보드를 이용해서 이전 내용을 "
"확인하는 것입니다. 이번에도 ``Ctrl-B`` 를 먼저 클릭 해준 뒤 ``Page Up`` 과 ``Page Down`` 키를 눌러"
" 봅시다. 키보드 만으로 터미널의 이전 내용을 탐색할 수 있다는 것을 확인할 수 있습니다. 탐색 모드에서 빠져 나오려면 ``q`` "
"키를 눌러주면 됩니다. 이 방법을 이용하면 마우스 지원을 끈 상태에서도 터미널 이전 내용 확인이 가능합니다."

#: ../../sessions_all/sessions_all.rst:651
msgid "Spawn multiple shells"
msgstr "여러 개의 쉘 띄우기"

#: ../../sessions_all/sessions_all.rst:653
msgid ""
"The main advantage of tmux is that you can launch and use multiple shells"
" in one terminal window. Since seeing is believing, let's press the "
"``Ctrl-B`` key and then the ``c``. You can see that the contents of the "
"existing window disappears and a new shell environment appears. But the "
"previous window is not terminated. Let's press ``Ctrl-B`` and then ``w``."
" You can now see the list of shells currently open on tmux like following"
" image. Here, the shell starting with ``0:`` is the shell environment you"
" first saw, and the shell starting with ``1:`` is the one you just "
"created. You can move between shells using the up/down keys. Place the "
"cursor on the shell ``0:`` and press the Enter key to select it."
msgstr ""
"tmux 의 가장 큰 장점은 하나의 터미널 창에서 여러 개의 쉘을 띄우고 사용할 수 있다는 점입니 다. 백문이 불여일견이니 "
"``Ctrl-B`` 키를 누른 후 ``c`` 키를 이어서 눌러봅시다. 기존 창의 내용이 사라지고 새로운 쉘 환경이 뜬 것을 확인할 "
"수 있습니다. 그러면 기존 창은 사라진 것일까요? 그렇지 않습니다. ``Ctrl-B`` 누른 후 ``w`` 키를 눌러 봅시다. "
"다음과 같이 현재 tmux 상에서 열려 있는 쉘 리스트가 조회되는 것을 볼 수 있습니다. 여기서 ``0:`` 으로 시작하는 쉘이 "
"처음 보던 쉘 환경이고, ``1:`` 로시작하는 쉘은 방금 새로 생성한 쉘입니다. 위/아래 방향 키를 이용해서 쉘 사이를 이동할 수"
" 있습니다. ``0:`` 번 쉘에 커서를 가져다 두고 엔터 키를 눌러 선택 해보겠습니다."

#: ../../sessions_all/sessions_all.rst:-1
msgid "tmux's multiple session management"
msgstr ""

#: ../../sessions_all/sessions_all.rst:667
msgid ""
"You can see the first shell environment appears. In this way, you can use"
" multiple shell environments within a web terminal. To exit or terminate "
"the current shell, just enter ``exit`` command or press ``Ctrl-B x`` key "
"and then type ``y``."
msgstr ""
"첫 번째 쉘 환경이 나타나는 것을 볼 수 있습니다. 이러한 방식으로 웹 터미널 내에서 여러 쉘 환경을 사용할 수 있습니다. 현재 "
"쉘을 종료하려면 ``exit`` 명령을 입력하거나 ``Ctrl-B x`` 키를 누른 다음 ``y`` 를 입력하십시오."

#: ../../sessions_all/sessions_all.rst:672
msgid "In summary:"
msgstr "정리하면 다음과 같습니다:"

#: ../../sessions_all/sessions_all.rst:674
msgid "``Ctrl-B c``: create a new tmux shell"
msgstr "``Ctrl-B c``: 새로운 tmux 쉘 생성"

#: ../../sessions_all/sessions_all.rst:675
msgid "``Ctrl-B w``: query current tmux shells and move around among them"
msgstr "``Ctrl-B w``: tmux 쉘 조회 및 이동/선택"

#: ../../sessions_all/sessions_all.rst:676
msgid "``exit`` or ``Ctrl-B x``: terminate the current shell"
msgstr "``exit`` 또는 ``Ctrl-B x``: 현재 tmux 쉘 종료"

#: ../../sessions_all/sessions_all.rst:678
msgid ""
"Combining the above commands allows you to perform various tasks "
"simultaneously on multiple shells."
msgstr "위 명령을 조합하여 여러 개의 쉘에서 동시에 다양한 작업을 수행할 수 있습니다."

